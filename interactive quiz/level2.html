<head>
  <title>Pong</title>
  <link rel="stylesheet" href="css/app.css">
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      background: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-image: url('images/gameboy.jpg');
      background-repeat: no-repeat;
      background-size: cover;
    }

    canvas {
      border: 1px solid white;
      margin-bottom: 1rem;
      margin-top: -530px;
    }

  </style>
</head>

<body>
  <h1>Level 2</h1>

  <p>Score: <span id="score">0</span></p>

  <a href="http://127.0.0.1:5500/level3.html">
    <button class="block"><b>Next Level</b></button>
  </a>

  <canvas width="300" height="285" id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const grid = 15;
    const paddleHeight = grid * 5; // 80
    const maxPaddleY = canvas.height - grid - paddleHeight;
  
    var paddleSpeed = 6;
    var ballSpeed = 2;
  
    const leftPaddle = {
      // start in the middle of the game on the left side
      x: grid * 2,
      y: canvas.height / 2 - paddleHeight / 2,
      width: grid,
      height: paddleHeight,
  
      // paddle velocity
      dy: 0
    };
  
    const rightPaddle = {
      // start in the middle of the game on the right side
      x: canvas.width - grid * 3,
      y: canvas.height / 2 - paddleHeight / 2,
      width: grid,
      height: paddleHeight,
  
      // paddle velocity
      dy: 0
    };
  
    const ball = {
      // start in the middle of the game
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: grid,
      height: grid,
  
      // keep track of when need to reset the ball position
      resetting: false,
  
      // ball velocity (start going to the top-right corner)
      dx: ballSpeed,
      dy: -ballSpeed
    };
  
    let score = 0;
    const scoreEl = document.getElementById('score');
  
    // check for collision between two objects using axis-aligned bounding box (AABB)
    function collides(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
             obj1.x + obj1.width > obj2.x &&
             obj1.y < obj2.y + obj2.height &&
             obj1.y + obj1.height > obj2.y;
    }
  
    function loop() {
  requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  // move paddles by their velocity
  leftPaddle.y += leftPaddle.dy;
  rightPaddle.y += rightPaddle.dy;

  // prevent paddles from going through walls
  if (leftPaddle.y < grid) {
    leftPaddle.y = grid;
  }
  else if (leftPaddle.y > maxPaddleY) {
    leftPaddle.y = maxPaddleY;
  }

  if (rightPaddle.y < grid) {
    rightPaddle.y = grid;
  }
  else if (rightPaddle.y > maxPaddleY) {
    rightPaddle.y = maxPaddleY;
  }

  // check for collision with paddles
  if (collides(ball, leftPaddle) || collides(ball, rightPaddle)) {
    ball.dx *= -1;
    ball.dy *= Math.random() < 0.5 ? -1 : 1;
    score++;
    scoreEl.innerHTML = score;
  }

  // move ball by its velocity
  ball.x += ball.dx;
  ball.y += ball.dy;

  // check for collision with walls
  if (ball.y < grid) {
    ball.y = grid;
    ball.dy *= -1;
  }
  else if (ball.y + grid > canvas.height - grid) {
    ball.y = canvas.height - grid * 2;
    ball.dy *= -1;
  }

  // check if the ball goes out of bounds
  if (ball.x < 0 || ball.x > canvas.width) {
    ball.resetting = true;
    setTimeout(() => {
      ball.resetting = false;
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      ball.dx = ballSpeed;
      ball.dy = -ballSpeed;
    }, 1000);
    
    // remove the alert from this block and place it outside
    if (score >= 5) {
      alert("Congratulations! You've advanced to the next level!");
      // call function to advance to next level
      advanceToNextLevel();
    }
  }

  // draw paddles and ball
  context.fillStyle = 'white';
  context.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
  context.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);

  if (!ball.resetting) {
    context.fillRect(ball.x, ball.y, ball.width, ball.height);
  }

  // check for score increment when the ball passes the left edge of canvas
  if (ball.x < 0) {
    score++;
    scoreEl.innerHTML = score;

    if (collides(ball, leftPaddle) || collides(ball, rightPaddle)) {
      ball.dx *= -1;
      ball.dy *= Math.random() < 0.5 ? -1 : 1;
      score++;
      scoreEl.innerHTML = score;
    }
  }
}




// draw ball
context.fillRect(ball.x, ball.y, ball.width, ball.height);
context.font = "20px Arial";
context.fillText("Score: " + (ball.score || 0), canvas.width/2 - 35, 20);

// listen to keyboard events to move the paddles
document.addEventListener('keydown', function(e) {
// up arrow key
if (e.which === 38) {
rightPaddle.dy = -paddleSpeed;
}
// down arrow key
else if (e.which === 40) {
rightPaddle.dy = paddleSpeed;
}
// w key
else if (e.which === 87) {
leftPaddle.dy = -paddleSpeed;
}
// s key
else if (e.which === 83) {
leftPaddle.dy = paddleSpeed;
}
});
// listen to keyboard events to stop the paddles when not moving
document.addEventListener('keyup', function(e) {
if (e.which === 38 || e.which === 40) {
rightPaddle.dy = 0;
}
else if (e.which === 87 || e.which === 83) {
leftPaddle.dy = 0;
}
});
// start the game loop
requestAnimationFrame(loop);
</script>
</body>